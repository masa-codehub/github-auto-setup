- rule_id: "CR-018"
  title: "Django REST APIのファイルアップロード時は例外ハンドリングとバリデーションを徹底する"
  description: |
    ファイルアップロードAPI実装時は、ファイル未添付・不正形式・サイズ超過・パース失敗・AI解析エラー・予期せぬ例外など、あらゆる異常系を網羅的に例外ハンドリングし、HTTP 400/500レスポンスを適切に返すこと。テスト要件を満たす単体テストも必ず実装する。
  category: "API設計・例外処理"
  example_bad: |
    class FileUploadAPIView(APIView):
        def post(self, request):
            file = request.FILES.get('file')
            parsed = parse(file.read())  # 例外処理なし
            return Response(parsed)
  example_good: |
    class FileUploadAPIView(APIView):
        def post(self, request):
            file = request.FILES.get('file')
            if not file:
                return Response({"detail": "No file uploaded."}, status=400)
            try:
                parsed = parse(file.read())
                return Response(parsed)
            except (ParsingError, AiParserError) as e:
                return Response({"detail": str(e)}, status=400)
            except Exception as e:
                return Response({"detail": "Unexpected error: " + str(e)}, status=500)

- rule_id: "CR-019"
  title: "DRFのAPIViewでは権限クラスを明示的に指定する"
  description: "Django REST FrameworkのAPIViewまたはViewSetでは、たとえデフォルト設定に依存している場合でも、`permission_classes`属性を明示的に指定すべきである。これにより、クラス単体でその権限要件が明確になり、可読性と保守性が向上する。"
  category: "セキュリティ"
  example_bad: |
    # settings.pyでデフォルトが設定されているため、省略されている
    class MyProtectedView(APIView):
        # permission_classes is not set
        def get(self, request):
            ...
  example_good: |
    from rest_framework.permissions import IsAuthenticated

    class MyProtectedView(APIView):
        permission_classes = [IsAuthenticated]

        def get(self, request):
            ...

- rule_id: "CR-021"
  title: "デバッグ用のコンソール出力を製品コードに残さない"
  description: "開発中のデバッグ目的で使用した`console.log`や`console.error`は、マージする前に必ず削除または適切なロガー、UI通知に置き換えること。これにより、意図しない情報漏洩を防ぎ、コンソールのクリーンさを保ち、エラーハンドリングの責務を明確にする。"
  category: "コード品質・セキュリティ"
  example_bad: |
    // デバッグ用のconsole.errorが残っている
    async function fetchData() {
      try {
        const response = await fetch('/api/data');
        return await response.json();
      } catch (error) {
        console.error('API Error:', error); // Not for production
        throw error;
      }
    }
  example_good: |
    // UI通知関数に置き換えられている
    async function fetchData() {
      try {
        const response = await fetch('/api/data');
        return await response.json();
      } catch (error) {
        showGlobalError('データの取得に失敗しました。'); // User-facing notification
        throw error;
      }
    }

- rule_id: "CR-022"
  title: "APIエラーハンドリングはUI通知・テスト駆動・責務分離を徹底する"
  description: |
    フロントエンドでAPI呼び出しを行う際は、ネットワークエラー・サーバーエラー・AI解析エラー等の異常系を全てcatchし、ユーザーに分かりやすいエラーメッセージをUI通知エリア（例: Bootstrap Alert）で表示すること。APIクライアント関数はエラーをthrowし、UI更新はイベントリスナー側で責務分離する。全ての異常系はJest等でテスト駆動する。
  category: "フロントエンド設計・例外処理"
  example_bad: |
    async function uploadIssueFile(formData) {
      const response = await fetch('/api/v1/parse-file', { method: 'POST', body: formData });
      return await response.json(); // エラー時のハンドリングなし
    }
    // ...
    // submitイベントで例外未捕捉
    uploadForm.addEventListener('submit', async (e) => {
      await uploadIssueFile(formData); // 失敗時にUI通知されない
    });
  example_good: |
    async function uploadIssueFile(formData) {
      const response = await fetch('/api/v1/parse-file', { method: 'POST', body: formData });
      if (!response.ok) {
        const err = await response.json();
        throw new Error(err.detail || 'API error');
      }
      return await response.json();
    }
    // ...
    uploadForm.addEventListener('submit', async (e) => {
      try {
        await uploadIssueFile(formData);
      } catch (e) {
        showUploadError(e.message);
      }
    });

- rule_id: "CR-023"
  title: "最短の手番で実装を完了させるための作業ルール"
  description: |
    実装・修正・レビュー対応など全ての作業は、最短の手番（最小のアクション数）で完了することを最優先とする。必要な情報は自動で収集し、推測できる部分は即時実行し、不要な確認や質問を挟まず、連続的かつ効率的にタスクを進める。エージェント型開発支援の原則とする。
  category: "開発プロセス・エージェント行動原則"
  example_bad: |
    // 毎回ユーザーに詳細を確認してから作業を進める
    // 既知の手順でも都度質問や確認を挟む
    // 1つの修正ごとに手動で指示を待つ
  example_good: |
    // 必要な情報は自動で検索・推論し、即座に実装を進める
    // まとめて修正・テスト・検証まで一気通貫で完了させる
    // ユーザーの手戻りや待ち時間を最小化する

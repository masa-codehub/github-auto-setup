- rule_id: "CR-018"
  title: "Django REST APIのファイルアップロード時は例外ハンドリングとバリデーションを徹底する"
  description: |
    ファイルアップロードAPI実装時は、ファイル未添付・不正形式・サイズ超過・パース失敗・AI解析エラー・予期せぬ例外など、あらゆる異常系を網羅的に例外ハンドリングし、HTTP 400/500レスポンスを適切に返すこと。テスト要件を満たす単体テストも必ず実装する。
  category: "API設計・例外処理"
  example_bad: |
    class FileUploadAPIView(APIView):
        def post(self, request):
            file = request.FILES.get('file')
            parsed = parse(file.read())  # 例外処理なし
            return Response(parsed)
  example_good: |
    class FileUploadAPIView(APIView):
        def post(self, request):
            file = request.FILES.get('file')
            if not file:
                return Response({"detail": "No file uploaded."}, status=400)
            try:
                parsed = parse(file.read())
                return Response(parsed)
            except (ParsingError, AiParserError) as e:
                return Response({"detail": str(e)}, status=400)
            except Exception as e:
                return Response({"detail": "Unexpected error: " + str(e)}, status=500)

- rule_id: "CR-019"
  title: "DRFのAPIViewでは権限クラスを明示的に指定する"
  description: "Django REST FrameworkのAPIViewまたはViewSetでは、たとえデフォルト設定に依存している場合でも、`permission_classes`属性を明示的に指定すべきである。これにより、クラス単体でその権限要件が明確になり、可読性と保守性が向上する。"
  category: "セキュリティ"
  example_bad: |
    # settings.pyでデフォルトが設定されているため、省略されている
    class MyProtectedView(APIView):
        # permission_classes is not set
        def get(self, request):
            ...
  example_good: |
    from rest_framework.permissions import IsAuthenticated

    class MyProtectedView(APIView):
        permission_classes = [IsAuthenticated]

        def get(self, request):
            ...

- rule_id: "CR-020"
  title: "AIを利用する処理は信頼度評価とフォールバック機構を必須とする"
  description: |
    AI（大規模言語モデル等）を利用するロジックでは、推論結果の信頼度を必ず評価し、信頼度が低い場合やエラー時には警告・エラー情報を返す、もしくは決定論的な処理にフォールバックする仕組みを実装すること。これによりAIの不確実性によるシステム障害や誤動作を防ぐ。
  category: "AI・信頼性設計"
  example_bad: |
    def parse_with_ai(text):
        # AIの出力をそのまま利用し、信頼度やエラーを考慮しない
        return ai_model.predict(text)
  example_good: |
    def parse_with_ai(text):
        result = ai_model.predict(text)
        confidence = evaluate_confidence(result)
        if confidence < 0.7:
            return {"warning": "AI推論の信頼度が低い", "result": result}
        return result

- rule_id: "CR-021"
  title: "デバッグ用のコンソール出力を製品コードに残さない"
  description: "開発中のデバッグ目的で使用した`console.log`や`console.error`は、マージする前に必ず削除または適切なロガー、UI通知に置き換えること。これにより、意図しない情報漏洩を防ぎ、コンソールのクリーンさを保ち、エラーハンドリングの責務を明確にする。"
  category: "コード品質・セキュリティ"
  example_bad: |
    // デバッグ用のconsole.errorが残っている
    async function fetchData() {
      try {
        const response = await fetch('/api/data');
        return await response.json();
      } catch (error) {
        console.error('API Error:', error); // Not for production
        throw error;
      }
    }
  example_good: |
    // UI通知関数に置き換えられている
    async function fetchData() {
      try {
        const response = await fetch('/api/data');
        return await response.json();
      } catch (error) {
        showGlobalError('データの取得に失敗しました。'); // User-facing notification
        throw error;
      }
    }

- rule_id: "CR-022"
  title: "APIエンドポイントURLは定数化しハードコードを避ける"
  description: |
    fetch等でAPIエンドポイントURLを直接文字列でハードコードせず、ファイル先頭で定数として定義し、全ての呼び出し箇所でその定数を参照すること。これにより、将来的なエンドポイント変更時の修正漏れや保守コストを低減できる。
  category: "保守性・可読性"
  example_bad: |
    async function uploadIssueFile(formData) {
      const response = await fetch('/api/v1/parse-file', {
        method: 'POST',
        body: formData
      });
      // ...
    }
  example_good: |
    const API_ENDPOINT = '/api/v1/parse-file';
    async function uploadIssueFile(formData) {
      const response = await fetch(API_ENDPOINT, {
        method: 'POST',
        body: formData
      });
      // ...
    }

- rule_id: "CR-023"
  title: "HTMLエスケープ関数は単一責任とし、改行変換等は呼び出し元で行う"
  description: |
    escapeHtml等のHTMLエスケープ関数は、純粋にHTML特殊文字のエスケープのみを担い、副次的な文字列変換（例: 改行→<br>等）は呼び出し元で明示的に行うこと。これにより、関数の副作用を排除し、単一責任の原則を守る。
  category: "保守性・単一責任原則"
  example_bad: |
    function escapeHtml(str) {
      return String(str)
        .replace(/[&<>'"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\'':'&#39;','"':'&quot;'}[c]))
        .replace(/\n/g, '<br>'); // ←副責任
    }
  example_good: |
    function escapeHtml(str) {
      return String(str).replace(/[&<>'"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\'':'&#39;','"':'&quot;'}[c]));
    }
    // 呼び出し元
    const html = escapeHtml(text).replace(/\n/g, '<br>');

- rule_id: "CR-024"
  title: "最短の手番で実装を完了させるための作業ルール"
  description: |
    実装・修正・レビュー対応など全ての作業は、最短の手番（最小のアクション数）で完了することを最優先とする。必要な情報は自動で収集し、推測できる部分は即時実行し、不要な確認や質問を挟まず、連続的かつ効率的にタスクを進める。エージェント型開発支援の原則とする。
  category: "開発プロセス・エージェント行動原則"
  example_bad: |
    // 毎回ユーザーに細かく確認し、手が止まる
    // 既知の手順でも都度質問や確認を挟む
    // 1つの修正ごとに手動で指示を待つ
  example_good: |
    // 必要な情報は自動で検索・推論し、即座に実装を進める
    // まとめて修正・テスト・検証まで一気通貫で完了させる
    // ユーザーの手戻りや待ち時間を最小化する

- rule_id: "CR-025"
  title: "フロントエンドの依存・テスト・ビルドはfrontendディレクトリ配下で一元管理し、ESM構成を安定させる"
  description: |
    Django等のバックエンドとフロントエンドを明確に分離して開発する場合、フロントエンドの依存（node_modules）・package.json・テスト・ビルド・CI/CDはfrontendディレクトリ配下に統合・完結させること。
    JestでESM(import/export)構文のテストを行う場合はBabel(babel.config.cjs)とJest(jest.config.mjs)の設定をfrontend配下に置き、`npm test`等のコマンドは必ずfrontendディレクトリ内で実行する。
    これにより、依存の競合、ESM構文エラー、設定ファイルが見つからない等の問題を防止し、保守性と再現性を高める。
  category: "フロントエンド・モノレポ運用指針"
  example_bad: |
    # ルートや複数箇所にnode_modulesが存在
    npm install       # /app/node_modulesができる
    cd frontend && npm install    # frontend/node_modulesもできる
    # ルートからテストを実行しようとしてエラーになる
    npm test
  example_good: |
    # frontend配下でのみ依存・テスト・ビルドを管理
    cd frontend
    npm install
    npm test
    # → frontend/node_modulesのみで全て完結し、設定も安定

- rule_id: "CR-026"
  title: "複数の分割戦略を持つ処理はStrategyパターンで分離する"
  description: |
    Markdown/YAML/JSONなど複数の分割ルールや戦略を扱う場合、if/elseや分岐の肥大化を避け、各戦略を関数・クラスとして分離しStrategyパターンで実装することで、拡張性・テスト容易性・保守性を高める。
  category: "設計・拡張性"
  example_bad: |
    def split(content, filetype, rule=None):
        if filetype == "md":
            # ...
        elif filetype == "yaml":
            # ...
        elif filetype == "json":
            # ...
  example_good: |
    class MarkdownSplitter: ...
    class YamlSplitter: ...
    class JsonSplitter: ...
    def split(content, filetype, rule=None):
        splitter = get_splitter(filetype)
        return splitter.split(content, rule)

- rule_id: "CR-027"
  title: "パース失敗時は必ず警告ログを出力する"
  description: |
    YAMLやJSON等のパース処理で例外（YAMLError, JSONDecodeError等）が発生した場合、例外を握りつぶして無視するのではなく、必ずlogger.warning等で警告ログを出力すること。これにより、障害発生時の原因特定やデバッグが容易になり、保守性が向上する。
  category: "ロギング・例外処理"
  example_bad: |
    def _split_yaml(self, content: str):
        try:
            data = yaml.safe_load(content)
        except yaml.YAMLError:
            return []  # ログ出力なしで握りつぶしている
  example_good: |
    import logging
    logger = logging.getLogger(__name__)
    def _split_yaml(self, content: str):
        try:
            data = yaml.safe_load(content)
        except yaml.YAMLError as e:
            logger.warning(f"Failed to parse YAML content due to YAMLError: {e}")
            return []

- rule_id: "CR-028"
  title: "データ変換ロジックは独立した純粋関数としてカプセル化する"
  description: "文字列からリストへの変換や特定パターンの抽出など、再利用可能なデータ変換処理は、それ自身の責務に特化した純粋関数として実装する。これにより、ロジックの単体テストが容易になり、異なる箇所からの再利用性も向上する。"
  category: "保守性・テスト容易性"
  example_bad: |
    # マッピング処理の途中で変換ロジックがハードコードされている
    def map_data(raw_data):
      issue = IssueData()
      if 'labels' in raw_data:
        # カンマ区切りを直接処理
        issue.labels = [label.strip() for label in raw_data['labels'].split(',')]
      return issue
  example_good: |
    # 変換ロジックが独立した関数になっている
    def to_list_by_comma(text: str) -> list[str]:
      return [item.strip() for item in text.split(',') if item.strip()]

    def map_data(raw_data):
      issue = IssueData()
      if 'labels' in raw_data:
        issue.labels = to_list_by_comma(raw_data['labels'])
      return issue
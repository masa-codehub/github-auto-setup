- rule_id: "CR-018"
  title: "Django REST APIのファイルアップロード時は例外ハンドリングとバリデーションを徹底する"
  description: |
    ファイルアップロードAPI実装時は、ファイル未添付・不正形式・サイズ超過・パース失敗・AI解析エラー・予期せぬ例外など、あらゆる異常系を網羅的に例外ハンドリングし、HTTP 400/500レスポンスを適切に返すこと。テスト要件を満たす単体テストも必ず実装する。
  category: "API設計・例外処理"
  example_bad: |
    class FileUploadAPIView(APIView):
        def post(self, request):
            file = request.FILES.get('file')
            parsed = parse(file.read())  # 例外処理なし
            return Response(parsed)
  example_good: |
    class FileUploadAPIView(APIView):
        def post(self, request):
            file = request.FILES.get('file')
            if not file:
                return Response({"detail": "No file uploaded."}, status=400)
            try:
                parsed = parse(file.read())
                return Response(parsed)
            except (ParsingError, AiParserError) as e:
                return Response({"detail": str(e)}, status=400)
            except Exception as e:
                return Response({"detail": "Unexpected error: " + str(e)}, status=500)

- rule_id: "CR-019"
  title: "DRFのAPIViewでは権限クラスを明示的に指定する"
  description: "Django REST FrameworkのAPIViewまたはViewSetでは、たとえデフォルト設定に依存している場合でも、`permission_classes`属性を明示的に指定すべきである。これにより、クラス単体でその権限要件が明確になり、可読性と保守性が向上する。"
  category: "セキュリティ"
  example_bad: |
    # settings.pyでデフォルトが設定されているため、省略されている
    class MyProtectedView(APIView):
        # permission_classes is not set
        def get(self, request):
            ...
  example_good: |
    from rest_framework.permissions import IsAuthenticated

    class MyProtectedView(APIView):
        permission_classes = [IsAuthenticated]

        def get(self, request):
            ...

- rule_id: "CR-021"
  title: "デバッグ用のコンソール出力を製品コードに残さない"
  description: "開発中のデバッグ目的で使用した`console.log`や`console.error`は、マージする前に必ず削除または適切なロガー、UI通知に置き換えること。これにより、意図しない情報漏洩を防ぎ、コンソールのクリーンさを保ち、エラーハンドリングの責務を明確にする。"
  category: "コード品質・セキュリティ"
  example_bad: |
    // デバッグ用のconsole.errorが残っている
    async function fetchData() {
      try {
        const response = await fetch('/api/data');
        return await response.json();
      } catch (error) {
        console.error('API Error:', error); // Not for production
        throw error;
      }
    }
  example_good: |
    // UI通知関数に置き換えられている
    async function fetchData() {
      try {
        const response = await fetch('/api/data');
        return await response.json();
      } catch (error) {
        showGlobalError('データの取得に失敗しました。'); // User-facing notification
        throw error;
      }
    }

- rule_id: "CR-022"
  title: "DOM操作ロジックはイベントリスナーから分離し、テスト容易性を確保する"
  description: "UIの描画や更新を行うDOM操作のロジックは、イベントリスナーのコールバック関数内に直接記述せず、独立した関数として切り出すべきである。これにより、DOM操作ロジックをUIイベントから切り離し、純粋なデータと期待されるDOMの状態だけで単体テストを行うことが可能になる。"
  category: "フロントエンド・テスト容易性"
  example_bad: |
    // イベントリスナー内にロジックが混在し、テストが困難
    uploadButton.addEventListener('click', async () => {
      const data = await fetchData();
      const tableBody = document.getElementById('issue-table-body');
      tableBody.innerHTML = ''; // Clear existing rows
      data.issues.forEach(issue => {
        const row = document.createElement('tr');
        row.innerHTML = `<td>${issue.title}</td>`;
        tableBody.appendChild(row);
      });
    });
  example_good: |
    // 描画ロジックを分離
    function renderIssues(issues) {
      const tableBody = document.getElementById('issue-table-body');
      if (!tableBody) return;
      tableBody.innerHTML = ''; // Clear existing rows
      issues.forEach(issue => {
        const row = document.createElement('tr');
        row.innerHTML = `<td>${issue.title}</td>`;
        tableBody.appendChild(row);
      });
    }

    // イベントリスナーはロジックの呼び出しに専念
    uploadButton.addEventListener('click', async () => {
      const data = await fetchData();
      renderIssues(data.issues);
    });

- rule_id: "CR-023"
  title: "APIエラーハンドリングはUI通知・テスト駆動・責務分離を徹底する"
  description: |
    フロントエンドでAPI呼び出しを行う際は、ネットワークエラー・サーバーエラー・AI解析エラー等の異常系を全てcatchし、ユーザーに分かりやすいエラーメッセージをUI通知エリア（例: Bootstrap Alert）で表示すること。APIクライアント関数はエラーをthrowし、UI更新はイベントリスナー側で責務分離する。全ての異常系はJest等でテスト駆動する。
  category: "フロントエンド設計・例外処理"
  example_bad: |
    async function uploadIssueFile(formData) {
      const response = await fetch('/api/v1/parse-file', { method: 'POST', body: formData });
      return await response.json(); // エラー時のハンドリングなし
    }
    // ...
    // submitイベントで例外未捕捉
    uploadForm.addEventListener('submit', async (e) => {
      await uploadIssueFile(formData); // 失敗時にUI通知されない
    });
  example_good: |
    async function uploadIssueFile(formData) {
      const response = await fetch('/api/v1/parse-file', { method: 'POST', body: formData });
      if (!response.ok) {
        const err = await response.json();
        throw new Error(err.detail || 'API error');
      }
      return await response.json();
    }
    // ...
    uploadForm.addEventListener('submit', async (e) => {
      try {
        await uploadIssueFile(formData);
      } catch (e) {
        showUploadError(e.message);
      }
    });

- rule_id: "CR-024"
  title: "最短の手番で実装を完了させるための作業ルール"
  description: |
    実装・修正・レビュー対応など全ての作業は、最短の手番（最小のアクション数）で完了することを最優先とする。必要な情報は自動で収集し、推測できる部分は即時実行し、不要な確認や質問を挟まず、連続的かつ効率的にタスクを進める。エージェント型開発支援の原則とする。
  category: "開発プロセス・エージェント行動原則"
  example_bad: |
    // 毎回ユーザーに細かく確認し、手が止まる
    // 既知の手順でも都度質問や確認を挟む
    // 1つの修正ごとに手動で指示を待つ
  example_good: |
    // 必要な情報は自動で検索・推論し、即座に実装を進める
    // まとめて修正・テスト・検証まで一気通貫で完了させる
    // ユーザーの手戻りや待ち時間を最小化する

- rule_id: "CR-025"
  title: "フロントエンドの依存・テスト・ビルドはfrontendディレクトリ配下で一元管理し、ESM構成を安定させる"
  description: |
    Django等のバックエンドとフロントエンドを明確に分離して開発する場合、フロントエンドの依存（node_modules）・package.json・テスト・ビルド・CI/CDはfrontendディレクトリ配下に統合・完結させること。
    JestでESM(import/export)構文のテストを行う場合はBabel(babel.config.cjs)とJest(jest.config.mjs)の設定をfrontend配下に置き、`npm test`等のコマンドは必ずfrontendディレクトリ内で実行する。
    これにより、依存の競合、ESM構文エラー、設定ファイルが見つからない等の問題を防止し、保守性と再現性を高める。
  category: "フロントエンド・モノレポ運用指針"
  example_bad: |
    # ルートや複数箇所にnode_modulesが存在
    npm install       # /app/node_modulesができる
    cd frontend && npm install   # frontend/node_modulesもできる
    # ルートからテストを実行しようとしてエラーになる
    npm test
  example_good: |
    # frontend配下でのみ依存・テスト・ビルドを管理
    cd frontend
    npm install
    npm test
    # → frontend/node_modulesのみで全て完結し、設定も安定